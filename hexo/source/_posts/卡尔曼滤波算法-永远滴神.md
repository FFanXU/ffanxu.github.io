---
title: 卡尔曼滤波算法，永远滴神！
date: 2021-07-12 11:40:50
tags:
    - 卡尔曼滤波
categories: 杂七杂八
---

鲁道夫 • 卡尔曼在一次访问 NASA 埃姆斯研究中心时，发现他的卡尔曼滤波算法能帮助解决阿波罗计划的轨道预测问题，最终，飞船正确驶向月球，完成了人类历史上的第一次登月。卡尔曼因而一举成名，后来还被美国总统奥巴马授予了国家科学勋章。

<p align="center">
    <img width="45%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712113922.jpeg">
</p>

<!-- more -->

让我们来想象一下阿波罗登月这个不可思议的神话：当飞行器飞向太空时，会不停地用各种传感器来测量自己的位置，希望自己在预定轨道上。但由于传感器的噪声影响，虽然它一直在测量和调整，但仍有可能慢慢偏离预定轨道。我们需要做的是，过滤掉那些噪声，估算出飞行器正确的位置。

我们先尝试下使用 S-G 滤波器（[Savitzky–Golay filter](https://en.wikipedia.org/wiki/Savitzky–Golay_filter))，它的核心思想是对一定长度窗口内的数据点进行 k 阶多项式拟合，其加权系数是通过在滑动窗口内对给定高阶多项式的最小二乘拟合得出。下面写了一段程序模拟 S-G 滤波器是如何实时处理一段噪声数据的：

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

N = 100
X = np.arange(N)

# 模拟 100 帧带有噪声的原始数据
Y1 = np.sin(np.linspace(0, np.pi*2, num=N)) + np.random.normal(0, 0.1, size=N)

window_length = 5      # 滑动窗口长度，该值需为正奇整数。
poly_order = 1         # 窗口内的数据点进行k阶多项式拟合，其值需要小于 window_length。

Y2 = []             # 用于存储平滑后的数据
cache_data = []     # 缓存队列

for i in range(N):                      # 实时地遍历每帧噪声数据
    origin_data = Y1[i]
    cache_data.append(origin_data)      # 将数据塞入缓存队列
    
    if i < window_length:               # 忽略前面几帧在滑动窗口以内的数据
        smooth_data = origin_data
    else:
        window_data = np.array(cache_data)  # 对滑动窗口数据进行平滑
        window_data = savgol_filter(window_data, window_length, poly_order)
        
        smooth_data = window_data[window_length//2] # 滑动窗口中间位置的数据
        cache_data.pop(0)                           # 队列尾部数据弹出
    
    Y2.append(smooth_data)
```

上述程序中提供了 100 帧带有正态分布噪声的数据，我们需要 S-G 滤波器对它们进行实时处理。由于窗口 size 设置成了 5，我们首先缓存了前 5 帧数据并对它们不进行任何平滑处理。等遍历到第 6 帧数据时，我们使用 savgol_filter 计算出缓存队列里经过平滑后的数据，并取出缓存队列中间的数据。为了保证滑动窗口（即缓存队列）的长度不变，在整个过程中我们需要不停地 push 数据和 pop 数据。整个滑动过程类似于下图所示：

<p align="center">
    <img width="60%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712175055.gif">
</p>

观察这个过程，发现有个非常严重的 bug：被平滑的数据需要依赖前几帧，也就是说 S-G 滤波具有一定的滞后性，比如说如果 window_size = 5，那么就会滞后 2 帧。这里截取一帧并放大显示（红色曲线表示的是滑动窗口）：

<p align="center">
    <img width="30%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712180925.png">
</p>






参考文献:

- [[1] 纪念一位深远地改变了现代世界的非著名发明家：鲁道夫•卡尔曼 ](https://www.sohu.com/a/114471342_354973)
