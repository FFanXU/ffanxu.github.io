---
title: 卡尔曼滤波算法，永远滴神！
date: 2021-07-12 11:40:50
tags:
    - 卡尔曼滤波
categories: 杂七杂八
---

鲁道夫 • 卡尔曼在一次访问 NASA 埃姆斯研究中心时，发现他的卡尔曼滤波算法能帮助解决阿波罗计划的轨道预测问题，最终，飞船正确驶向月球，完成了人类历史上的第一次登月。卡尔曼因而一举成名，后来还被美国总统奥巴马授予了国家科学勋章。

<p align="center">
    <img width="45%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712113922.jpeg">
</p>

<!-- more -->

让我们来想象一下阿波罗登月这个不可思议的神话：当飞行器飞向太空时，会不停地用各种传感器来测量自己的位置，希望自己在预定轨道上。但由于传感器的噪声影响，虽然它一直在测量和调整，但仍有可能慢慢偏离预定轨道。我们需要做的是，过滤掉那些噪声，估算出飞行器正确的位置。

我们先尝试下使用 S-G 滤波器（[Savitzky–Golay filter](https://en.wikipedia.org/wiki/Savitzky–Golay_filter))，它的核心思想是对一定长度窗口内的数据点进行 k 阶多项式拟合，其加权系数是通过在滑动窗口内对给定高阶多项式的最小二乘拟合得出。下面写了一段程序模拟 S-G 滤波器是如何实时处理一段噪声数据的：

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

N = 100
X = np.arange(N)

# 模拟 100 帧带有噪声的原始数据
Y1 = np.sin(np.linspace(0, np.pi*2, num=N)) + np.random.normal(0, 0.1, size=N)

window_length = 5      # 滑动窗口长度，该值需为正奇整数。
poly_order = 1         # 窗口内的数据点进行k阶多项式拟合，其值需要小于 window_length。

Y2 = []             # 用于存储平滑后的数据
cache_data = []     # 缓存队列

for i in range(N):                      # 实时地遍历每帧噪声数据
    origin_data = Y1[i]
    cache_data.append(origin_data)      # 将数据塞入缓存队列
    
    if i < window_length:               # 忽略前面几帧在滑动窗口以内的数据
        smooth_data = origin_data
    else:
        window_data = np.array(cache_data)  # 对滑动窗口数据进行平滑
        window_data = savgol_filter(window_data, window_length, poly_order)
        
        smooth_data = window_data[window_length//2] # 滑动窗口中间位置的数据
        cache_data.pop(0)                           # 队列尾部数据弹出
    
    Y2.append(smooth_data)
```

上述程序中提供了 100 帧带有正态分布噪声的数据，我们需要 S-G 滤波器对它们进行实时处理。由于窗口 size 设置成了 5，我们首先缓存了前 5 帧数据并对它们不进行任何平滑处理。等遍历到第 6 帧数据时，我们使用 savgol_filter 计算出缓存队列里经过平滑后的数据，并取出缓存队列中间的数据。为了保证滑动窗口（即缓存队列）的长度不变，在整个过程中我们需要不停地 push 数据和 pop 数据。整个滑动过程类似于下图所示：

<p align="center">
    <img width="60%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712175055.gif">
</p>

观察这个过程，发现有个非常严重的 bug：被平滑的数据需要依赖前几帧，也就是说 S-G 滤波具有一定的滞后性，比如说如果 window_size = 5，那么就会滞后 2 帧。这里截取一帧并放大显示（红色曲线表示的是滑动窗口）：

<p align="center">
    <img width="30%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712180925.png">
</p>

而卡尔曼滤波可以较好地解决这个问题的痛点，<font color=red><strong>它只要获知上一时刻状态的估计值以及当前状态的观测值就可以计算出当前状态的估计值，因此不需要记录观测或者估计的历史信息。</strong></font>在讲卡尔曼滤波之前，我们先来了解两个例子：

### 例子1 – 金条重量

在本例中，我们将估计金条的重量。我们将使用一个无偏秤，也就是说，它没有系统误差，但每次称重会伴随着随机噪声。

<p align="center">
    <img width="35%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712205621.png">
</p>

在本例中，系统是金条，系统的状态就是金条的重量。假设金条的重量在短时间内不发生变化，即系统的动态模型是恒定的。为了估计系统的状态(金条的重量)，可以进行多次测量并求平均值。

<p align="center">
    <img width="60%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210712205737.png">
</p>

经过 N 次测量，其估计值是所有测量值的平均值：

<p align="center">
    <img width="80%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713142228.png">
</p>

在上面方程式中，我们需要记住所有历史测量数据。假设我们没有笔和纸来记录，也不能凭的记忆记下所有的历史测量数据。但我们可以仅用上一次的估计值和一点小小的调整(在现实生活的应用中，我们想节省计算机内存)，以及一个数学小技巧来做到这一点：

<p align="center">
    <img width="100%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713142529.png">
</p>

上述方程是卡尔曼滤波五个方程之一，名为状态更新 State Update Equation。其含义为：

<p align="center">
    <img width="100%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713143804.png">
</p>

因此，状态更新方程为:

<p align="center">
    <img width="50%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713151127.png">
</p>

让我们继续看这个例子，在进行第一次测量前需要预设一个初始猜测值，这个值不用很精准。下面为比较详细的计算过程：

- 第 0 次预测：

我们对金条重量的初步估计是1000克。滤波器初始化操作仅需一次，不会用在下一次迭代中。

<p align="center">
    <img width="15%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713151504.png">
</p>

状态的下一个估计值(预测值)等于初始值：

<p align="center">
    <img width="21%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713152600.png">
</p>

- 第 1 次预测：

第一次秤重：

<p align="center">
    <img width="13.5%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713152048.png">
</p>

计算卡尔曼增益：

<p align="center">
    <img width="13%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713152205.png">
</p>

用状态更新方程计算当前估计值：

<p align="center">
    <img width="65%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713152332.png">
</p>

> <font color=red>在这个特定的例子中，最初的猜测可以是任何值，因为 α1=1，初始猜测值在第一次迭代就被消去了。</font>

状态的下一个估计值(预测值)等于当前的估计值:

<p align="center">
    <img width="22%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713152817.png">
</p>

上述过程一直进行到第 10 次预测，下图比较了测量值、估计值和真实值。

<p align="center">
    <img width="70%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713153123.png">
</p>

### 例子2 – 飞行器位置
假设在一个一维空间，有一架飞行器正在向远离雷达的方向飞行。在一维空间中，雷达的角度不变，飞行器的高度不变，如下图所示。

<p align="center">
    <img width="70%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713155516.png">
</p>

已知前面 N 个时刻飞机的位置，并且雷达已经测量到了此刻飞机的位置，那么我们如何估算出此刻飞机真正的位置呢？

- 方法 1：使用雷达的测量值，但是雷达一般都有一定的系统误差怎么办。
- 方法 2：利用这个时间点之前的所有数据，预测这个时间点的数据。当然，这个预测值也是不准的。

<p align="center">
    <img width="100%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210714111700.png">
</p>


这两种方法告诉了我们不同的答案，两种方法都有一定的可信度。那能否将两种答案相融合呢，卡尔曼滤波就是做了这样的事情。<strong><font color=red>如下图所示，假设两种方法的误差都满足正态分布，如下图所示。如果正态分布越尖锐陡峭，则说明这种方法的预测结果越可信；如果越缓和平坦，则说明越不可信。</font></strong>为了融合这两种方法的预测结果，我们给这两种分布分别赋予一个权重，该权重代表了这个分布对融合结果的重要性。经过融合后的分布变得比之前两种分布更加尖锐，这表明结果更加可信了。

<p align="center">
    <img width="70%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210713175050.jpeg">
</p>

### Kalman filter 的数学表示

Kalman 滤波分为 2 个步骤，预测(predict)和校正(correct)。<font color=red>预测是基于上一时刻状态估计当前时刻状态，而校正则是综合当前时刻的估计状态与观测状态，估计出最优的状态。</font>预测与校正的过程如下：

- <strong>预测：根据上一时刻（k-1 时刻）的后验估计值来估计当前时刻（k时刻）的状态，得到 k 时刻的先验估计值;</strong>

<p align="center">
    <img width="30%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210714161211.png">
</p>

- <strong>校正：使用当前时刻的测量值来校正预测阶段的估计值，得到当前时刻的后验估计值。</strong>

<p align="center">
    <img width="33%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210714161316.png">
</p>

<p align="center">
    <img width="100%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210714201546.png">
</p>

<strong><font color=red>预测阶段负责根据前一时刻的状态估计值来推算当前时刻的状态变量先验估计值和误差协方差先验估计值；校正阶段负责将先验估计和新的测量变量相融合改进的后验估计。</font></strong>卡尔曼滤波算法是一个递归的预测—校正方法，即只要获知上一时刻状态的估计值以及当前状态的观测值就可以计算出当前状态的估计值，因此不需要记录观测或者估计的历史信息。

### Python 代码实现

假设真实值为 `x=-0.37727 ，A=1， H=1`，观测值存在噪声，那么如何估计出实际的值呢？[美国北卡大学的 Andrew D. Straw 给出了一份代码实现](https://scipy-cookbook.readthedocs.io/items/KalmanFiltering.html)：

```python
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['figure.figsize'] = (10, 8)

# intial parameters
n_iter = 50
sz = (n_iter,) # size of array

# 真实值 
x = -0.37727 # truth value (typo in example at top of p. 13 calls this z)

# 观测值 , 观测时存在噪声
z = np.random.normal(x,0.1,size=sz) # observations (normal about x, sigma=0.1) 
Q = 1e-5 # process variance

# allocate space for arrays
xhat=np.zeros(sz)      # x 滤波估计值  
P=np.zeros(sz)         # 滤波估计协方差矩阵
xhatminus=np.zeros(sz) # x 估计值 
Pminus=np.zeros(sz)    # 估计协方差矩阵
K=np.zeros(sz)         # 卡尔曼增益

R = 0.1**2 # estimate of measurement variance, change to see effect

# intial guesses
xhat[0] = 0.0
P[0] = 1.0

for k in range(1,n_iter):
    # 预测
    xhatminus[k] = xhat[k-1] # X(k|k-1) = AX(k-1|k-1) + BU(k) + W(k),A=1,BU(k) = 0
    Pminus[k] = P[k-1]+Q     # P(k|k-1) = AP(k-1|k-1)A' + Q(k), A=1

    # 更新
    K[k] = Pminus[k]/( Pminus[k]+R )    # Kg(k)=P(k|k-1)H'/[HP(k|k-1)H' + R], H=1
    xhat[k] = xhatminus[k]+K[k]*(z[k]-xhatminus[k]) # X(k|k) = X(k|k-1) + Kg(k)[Z(k) - HX(k|k-1)], H=1
    P[k] = (1-K[k])*Pminus[k]                       # P(k|k) = (1 - Kg(k)H)P(k|k-1), H=1

plt.figure()
plt.plot(z,'k+',label='noisy measurements')         # 测量值
plt.plot(xhat,'b-',label='a posteri estimate')      # 估计值
plt.axhline(x,color='g',label='truth value')        # 真实值
plt.legend()
plt.title('Estimate vs. iteration step', fontweight='bold')
plt.xlabel('Iteration')
plt.ylabel('Voltage')

plt.figure()
valid_iter = range(1,n_iter) # Pminus not valid at step 0
plt.plot(valid_iter,Pminus[valid_iter],label='a priori error estimate')
plt.title('Estimated $\it{\mathbf{a \ priori}}$ error vs. iteration step', fontweight='bold')
plt.xlabel('Iteration')
plt.ylabel('$(Voltage)^2$')
plt.setp(plt.gca(),'ylim',[0,.01])
plt.show()
```

<p align="center">
    <img width="100%" src="https://cdn.jsdelivr.net/gh/YunYang1994/blogimgs/卡尔曼滤波-永远滴神-20210714204613.png">
</p>




参考文献:

- [[1] 纪念一位深远地改变了现代世界的非著名发明家：鲁道夫•卡尔曼 ](https://www.sohu.com/a/114471342_354973)
- [[2] An Introduction to the Kalman Filter ](https://courses.cs.washington.edu/courses/cse571/03wi/notes/welch-bishop-tutorial.pdf)
- [[3] https://www.kalmanfilter.net ](https://www.kalmanfilter.net/CN/default_cn.aspx)
